"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allureCypress = exports.AllureCypress = void 0;
var _allureJsCommons = require("allure-js-commons");
var _sdk = require("allure-js-commons/sdk");
var _reporter = require("allure-js-commons/sdk/reporter");
var _utils = require("./utils.js");
var _excluded = ["resultsDir", "videoOnFailOnly"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], t.indexOf(o) >= 0 || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
class AllureCypress {
  constructor(config) {
    _defineProperty(this, "allureRuntime", void 0);
    _defineProperty(this, "messagesByAbsolutePath", new Map());
    _defineProperty(this, "runContextByAbsolutePath", new Map());
    _defineProperty(this, "globalHooksMessages", []);
    _defineProperty(this, "videoOnFailOnly", false);
    var _ref = config || {},
      {
        resultsDir = "./allure-results",
        videoOnFailOnly = false
      } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded);
    this.videoOnFailOnly = videoOnFailOnly;
    this.allureRuntime = new _reporter.ReporterRuntime(_objectSpread({
      writer: new _reporter.FileSystemWriter({
        resultsDir
      })
    }, rest));
  }
  createEmptyRunContext(absolutePath) {
    this.runContextByAbsolutePath.set(absolutePath, {
      executables: [],
      steps: [],
      scopes: [],
      globalHooksMessages: []
    });
  }
  attachToCypress(on) {
    on("task", {
      readAllureTestPlan: () => {
        var _parseTestPlan;
        return (_parseTestPlan = (0, _reporter.parseTestPlan)()) !== null && _parseTestPlan !== void 0 ? _parseTestPlan : null;
      },
      allureReportTest: _ref2 => {
        var {
          messages,
          absolutePath
        } = _ref2;
        this.messagesByAbsolutePath.set(absolutePath, messages);
        return null;
      },
      allureReportSpec: spec => {
        this.createEmptyRunContext(spec.absolute);
        this.endSpec(spec);
        return null;
      }
    });
  }
  endRun(result) {
    result.runs.forEach(run => {
      this.createEmptyRunContext(run.spec.absolute);
      this.endSpec(run.spec, run.video || undefined);
    });
    this.allureRuntime.writeEnvironmentInfo();
    this.allureRuntime.writeCategoriesDefinitions();
  }
  endSpec(spec, cypressVideoPath) {
    var _this$messagesByAbsol;
    var specMessages = (_this$messagesByAbsol = this.messagesByAbsolutePath.get(spec.absolute)) !== null && _this$messagesByAbsol !== void 0 ? _this$messagesByAbsol : [];
    var runContext = this.runContextByAbsolutePath.get(spec.absolute);
    var isSpecFailed = specMessages.some(message => message.type === "cypress_test_end" && (message.data.status === _allureJsCommons.Status.FAILED || message.data.status === _allureJsCommons.Status.BROKEN));
    var shouldVideoBeAttached = (!this.videoOnFailOnly || isSpecFailed) && cypressVideoPath;
    specMessages.forEach((message, i) => {
      var _data;
      // we add cypressTestId to messages where it's possible because the field is very useful to glue data
      // @ts-ignore
      var previousMessagesSlice = specMessages.slice(0, i);
      var lastHookMessage = (0, _utils.toReversed)(previousMessagesSlice).find(_ref3 => {
        var {
          type
        } = _ref3;
        return type === "cypress_hook_start" || type === "cypress_hook_end";
      });
      if (message.type === "cypress_suite_start") {
        var scopeUuid = this.allureRuntime.startScope();
        runContext.scopes.push(scopeUuid);
        return;
      }
      if (message.type === "cypress_suite_end") {
        var _scopeUuid = runContext.scopes.pop();
        this.allureRuntime.writeScope(_scopeUuid);
        return;
      }
      if (message.type === "cypress_hook_start" && message.data.global) {
        runContext.globalHooksMessages.push(message);
        return;
      }
      if (message.type === "cypress_hook_start") {
        var fixtureUuid = this.allureRuntime.startFixture((0, _utils.last)(runContext.scopes), message.data.type, {
          name: message.data.name,
          start: message.data.start
        });
        runContext.executables.push(fixtureUuid);
        return;
      }
      if (message.type === "cypress_hook_end" && lastHookMessage !== null && lastHookMessage !== void 0 && (_data = lastHookMessage.data) !== null && _data !== void 0 && _data.global && (lastHookMessage === null || lastHookMessage === void 0 ? void 0 : lastHookMessage.type) === "cypress_hook_start") {
        runContext.globalHooksMessages.push(message);
        return;
      }
      if (message.type === "cypress_hook_end") {
        var _fixtureUuid = runContext.executables.pop();
        this.allureRuntime.updateFixture(_fixtureUuid, r => {
          r.stage = _allureJsCommons.Stage.FINISHED;
          r.status = message.data.status;
          r.stop = message.data.stop;
          if (message.data.statusDetails) {
            r.statusDetails = message.data.statusDetails;
          }
        });
        this.allureRuntime.stopFixture(_fixtureUuid);
        return;
      }
      if (message.type === "cypress_test_start") {
        var suiteLabels = (0, _reporter.getSuiteLabels)(message.data.specPath.slice(0, -1));
        var testTitle = message.data.specPath[message.data.specPath.length - 1];
        var titleMetadata = (0, _sdk.extractMetadataFromString)(testTitle);
        var testUuid = this.allureRuntime.startTest({
          name: titleMetadata.cleanTitle || testTitle,
          start: message.data.start,
          fullName: "".concat(message.data.filename, "#").concat(message.data.specPath.join(" ")),
          stage: _allureJsCommons.Stage.RUNNING,
          labels: [{
            name: _allureJsCommons.LabelName.LANGUAGE,
            value: "javascript"
          }, {
            name: _allureJsCommons.LabelName.FRAMEWORK,
            value: "cypress"
          }, ...suiteLabels, ...titleMetadata.labels, ...(0, _reporter.getEnvironmentLabels)()]
        }, runContext.scopes);
        runContext.executables.push(testUuid);
        return;
      }
      if (message.type === "cypress_test_end") {
        var _testUuid = runContext.executables.pop();
        this.allureRuntime.updateTest(_testUuid, result => {
          result.stage = _allureJsCommons.Stage.FINISHED;
          result.status = message.data.status;
          if (message.data.retries > 0) {
            result.parameters.push({
              name: "Retry",
              value: message.data.retries.toString()
            });
          }
          if (!message.data.statusDetails) {
            return;
          }
          result.statusDetails = message.data.statusDetails;
        });
        this.allureRuntime.stopTest(_testUuid);
        this.allureRuntime.writeTest(_testUuid);
        return;
      }

      // we can get error when we try to attach screenshot to a failed test because there is no test due to error in hook
      if (runContext.executables.length === 0) {
        return;
      }
      if (message.type === "cypress_command_start") {
        var lastExecutableUuid = (0, _utils.last)(runContext.executables);
        var lastStepUuid = (0, _utils.last)(runContext.steps);
        var stepUuid = this.allureRuntime.startStep(lastExecutableUuid, lastStepUuid, {
          name: message.data.name,
          parameters: message.data.args.map((arg, j) => ({
            name: "Argument [".concat(j, "]"),
            value: arg
          }))
        });
        runContext.steps.push(stepUuid);
        return;
      }
      if (message.type === "cypress_command_end") {
        var _stepUuid = runContext.steps.pop();
        this.allureRuntime.updateStep(_stepUuid, r => {
          r.status = message.data.status;
          if (message.data.statusDetails) {
            r.statusDetails = message.data.statusDetails;
          }
        });
        this.allureRuntime.stopStep(_stepUuid);
        return;
      }
      this.allureRuntime.applyRuntimeMessages((0, _utils.last)(runContext.executables), [message]);
    });
    if (shouldVideoBeAttached) {
      var fixtureUuid = this.allureRuntime.startFixture(runContext.scopes[0], "after", {
        name: "Cypress video",
        status: _allureJsCommons.Status.PASSED,
        stage: _allureJsCommons.Stage.FINISHED
      });
      this.allureRuntime.writeAttachment(fixtureUuid, undefined, "Cypress video", cypressVideoPath, {
        contentType: _allureJsCommons.ContentType.MP4
      });
      this.allureRuntime.stopFixture(fixtureUuid);
    }
    if (runContext.globalHooksMessages.length > 0) {
      runContext.globalHooksMessages.forEach(message => {
        if (message.type === "cypress_hook_start") {
          var _fixtureUuid2 = this.allureRuntime.startFixture(runContext.scopes[0], message.data.type, {
            name: message.data.name,
            start: message.data.start
          });
          runContext.executables.push(_fixtureUuid2);
          return;
        }
        if (message.type === "cypress_hook_end") {
          var _fixtureUuid3 = runContext.executables.pop();
          this.allureRuntime.updateFixture(_fixtureUuid3, r => {
            r.status = message.data.status;
            r.stop = message.data.stop;
            if (message.data.statusDetails) {
              r.statusDetails = message.data.statusDetails;
            }
          });
          this.allureRuntime.stopFixture(_fixtureUuid3);
        }
      });
    }
    this.allureRuntime.writeScope(runContext.scopes.pop());
  }
}
exports.AllureCypress = AllureCypress;
var allureCypress = (on, allureConfig) => {
  var allureCypressReporter = new AllureCypress(allureConfig);
  allureCypressReporter.attachToCypress(on);
  on("after:run", results => {
    allureCypressReporter.endRun(results);
  });
  return allureCypressReporter;
};
exports.allureCypress = allureCypress;
//# sourceMappingURL=reporter.js.map