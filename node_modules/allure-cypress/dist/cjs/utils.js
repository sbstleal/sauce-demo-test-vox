"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uint8ArrayToBase64 = exports.toReversed = exports.last = exports.isTestPresentInTestPlan = exports.isGlobalHook = exports.isCommandShouldBeSkipped = exports.getSuitePath = exports.getHookType = void 0;
var _allureJsCommons = require("allure-js-commons");
var _sdk = require("allure-js-commons/sdk");
var _model = require("./model.js");
var uint8ArrayToBase64 = data => {
  // @ts-ignore
  var u8arrayLike = Array.isArray(data) || data.buffer;
  if (!u8arrayLike) {
    return data;
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return btoa(String.fromCharCode.apply(null, data));
};
exports.uint8ArrayToBase64 = uint8ArrayToBase64;
var getSuitePath = test => {
  var path = [];
  var currentSuite = test.parent;
  while (currentSuite) {
    if (currentSuite.title) {
      path.unshift(currentSuite.title);
    }
    currentSuite = currentSuite.parent;
  }
  return path;
};
exports.getSuitePath = getSuitePath;
var isCommandShouldBeSkipped = command => {
  var _last;
  if (((_last = last(command.attributes.args)) === null || _last === void 0 ? void 0 : _last.log) === false) {
    return true;
  }
  if (command.attributes.name === "task" && command.attributes.args[0] === "allureReportTest") {
    return true;
  }

  // we don't need to report then commands because it's just a promise handle
  if (command.attributes.name === "then") {
    return true;
  }

  // we should skip artificial wrap from allure steps
  if (command.attributes.name === "wrap" && command.attributes.args[0] === _model.ALLURE_REPORT_STEP_COMMAND) {
    return true;
  }
  return false;
};
exports.isCommandShouldBeSkipped = isCommandShouldBeSkipped;
var toReversed = arr => {
  var result = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
};
exports.toReversed = toReversed;
var isGlobalHook = hookName => {
  return /(before|after) all/.test(hookName);
};
exports.isGlobalHook = isGlobalHook;
var getHookType = hookName => {
  return hookName.includes("before") ? "before" : "after";
};
exports.getHookType = getHookType;
var last = arr => {
  return arr[arr.length - 1];
};
exports.last = last;
var isTestPresentInTestPlan = (test, spec, testPlan) => {
  var testFullName = "".concat(spec.relative, "#").concat(test.titlePath.join(" "));
  var {
    labels
  } = (0, _sdk.extractMetadataFromString)(test.title);
  var allureIdLabel = labels.find(_ref => {
    var {
      name
    } = _ref;
    return name === _allureJsCommons.LabelName.ALLURE_ID;
  });
  return testPlan.tests.some(_ref2 => {
    var {
      id,
      selector = ""
    } = _ref2;
    var idMatched = id ? String(id) === (allureIdLabel === null || allureIdLabel === void 0 ? void 0 : allureIdLabel.value) : false;
    var selectorMatched = selector === testFullName;
    return idMatched || selectorMatched;
  });
};
exports.isTestPresentInTestPlan = isTestPresentInTestPlan;
//# sourceMappingURL=utils.js.map