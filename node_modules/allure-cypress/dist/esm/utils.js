import { LabelName } from "allure-js-commons";
import { extractMetadataFromString } from "allure-js-commons/sdk";
import { ALLURE_REPORT_STEP_COMMAND } from "./model.js";
export var uint8ArrayToBase64 = data => {
  // @ts-ignore
  var u8arrayLike = Array.isArray(data) || data.buffer;
  if (!u8arrayLike) {
    return data;
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
  return btoa(String.fromCharCode.apply(null, data));
};
export var getSuitePath = test => {
  var path = [];
  var currentSuite = test.parent;
  while (currentSuite) {
    if (currentSuite.title) {
      path.unshift(currentSuite.title);
    }
    currentSuite = currentSuite.parent;
  }
  return path;
};
export var isCommandShouldBeSkipped = command => {
  var _last;
  if (((_last = last(command.attributes.args)) === null || _last === void 0 ? void 0 : _last.log) === false) {
    return true;
  }
  if (command.attributes.name === "task" && command.attributes.args[0] === "allureReportTest") {
    return true;
  }

  // we don't need to report then commands because it's just a promise handle
  if (command.attributes.name === "then") {
    return true;
  }

  // we should skip artificial wrap from allure steps
  if (command.attributes.name === "wrap" && command.attributes.args[0] === ALLURE_REPORT_STEP_COMMAND) {
    return true;
  }
  return false;
};
export var toReversed = arr => {
  var result = [];
  for (var i = arr.length - 1; i >= 0; i--) {
    result.push(arr[i]);
  }
  return result;
};
export var isGlobalHook = hookName => {
  return /(before|after) all/.test(hookName);
};
export var getHookType = hookName => {
  return hookName.includes("before") ? "before" : "after";
};
export var last = arr => {
  return arr[arr.length - 1];
};
export var isTestPresentInTestPlan = (test, spec, testPlan) => {
  var testFullName = "".concat(spec.relative, "#").concat(test.titlePath.join(" "));
  var {
    labels
  } = extractMetadataFromString(test.title);
  var allureIdLabel = labels.find(_ref => {
    var {
      name
    } = _ref;
    return name === LabelName.ALLURE_ID;
  });
  return testPlan.tests.some(_ref2 => {
    var {
      id,
      selector = ""
    } = _ref2;
    var idMatched = id ? String(id) === (allureIdLabel === null || allureIdLabel === void 0 ? void 0 : allureIdLabel.value) : false;
    var selectorMatched = selector === testFullName;
    return idMatched || selectorMatched;
  });
};
//# sourceMappingURL=utils.js.map